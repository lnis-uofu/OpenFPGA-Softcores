#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Timing path analyzer tool: reads the report timing file generated by VPR and
extends the description of each point composing the path (PB type, block ID,
coordinates, ...) using VPR *.net and *.place reports.
"""

import os
import sys
import argparse
import numpy as np
from glob import glob

# 'tools/' is a sibling folders of 'parsers/', the following command ensures
# the import of libraries from the sibling folder.
sys.path.append(os.path.dirname(os.path.abspath(os.path.join(__file__, ".."))))

from parsers.vpr_report_timing_parser import VprReportTimingParser
from parsers.vpr_net_parser import VprNetParser
from parsers.vpr_place_parser import VprPlaceParser

## Command-line arguments
def parse_args():
    ap = argparse.ArgumentParser(
        description     = __doc__,
        formatter_class = argparse.RawTextHelpFormatter,
    )
    # positional arguments
    ap.add_argument(
        'search_path',
        metavar = '<search-path>',
        default = os.path.join("run_dir", "latest"),
        help    = "root path to recursively search report files (default: '%(default)s')",
    )
    # optional arguments
    ap.add_argument(
        '-d', '--debug',
        action  = 'store_true',
        help    = "enable debug mode",
    )
    ap.add_argument(
        '-p', '--path-id',
        type    = int,
        metavar = "<path-id>",
        default = 0,
        help    = "define the path number to print (default: %(default)s)",
    )
    ap.add_argument(
        '--hold',
        action  = 'store_true',
        help    = "parse the hold report timing file",
    )
    ap.add_argument(
        '-o', '--output',
        metavar = "<rpt-file>",
        help    = "analyze all paths in the report file and save them",
    )
    # return the user arguments
    return ap.parse_args()

## Find a filename in a root path, using a recursive approach
def find_filename(path, filename):
    file = glob(os.path.join(path, filename), recursive=True)
    if not file:
        print(f"[-] File '{filename}' not found in '{path}'.")
        sys.exit(1)
    return file[0]

## Evaluate the Manhattan distance regarding to point placement
def manhattan_analysis(table):
    x1, y1 = table[0]['x'], table[0]['y']
    x2, y2 = table[-1]['x'], table[-1]['y']
    # Manhattan distance
    mw, mh = np.abs(x1 - x2), np.abs(y1 - y2)
    # path distance
    dw, dh = 0, 0
    # for each point in the net calculate the path distance
    for line in table[1:]:
        x2, y2 = line['x'], line['y']
        dw    += np.abs(x1 - x2)
        dh    += np.abs(y1 - y2)
        x1, y1 = x2, y2
    return {
        'euclidean' : np.sqrt(mw**2 + mh**2),
        'manhattan' : mw + mh,
        'm_width'   : mw,
        'm_height'  : mh,
        'distance'  : dw + dh,
        'd_width'   : dw,
        'd_height'  : dh,
        'm_ratio'   : (dw + dh) / float(mw + mh),
    }

## Print data (list of dict) in a table format
def print_table(data, headers, sepwidth=2, precision=3, stream=sys.stdout):
    # measure column widths
    widths = [len(h[1]) for h in headers]
    for row in data:
        for idx, (col, _) in enumerate(headers):
            if isinstance(row[col], float):
                widths[idx] = max(widths[idx], len(f"{row[col]:.{precision}f}"))
            else:
                widths[idx] = max(widths[idx], len(str(row[col])))
    # print headers
    head = (' '*sepwidth).join([f"{h[1]:{w}}" for h, w in zip(headers, widths)])
    print(head, file=stream)
    print("-"*len(head), file=stream)
    # print table
    for idx, row in enumerate(data):
        line = []
        for (col, _), w in zip(headers, widths):
            if isinstance(row[col], float):
                line.append(f"{row[col]:{w-1-precision}.{precision}f}")
            else:
                line.append(f"{row[col]:{w}}")
        print((' '*sepwidth).join(line), file=stream)
    print("-"*len(head), file=stream)

## Print statistics of the path
def print_statistics(table, stream=sys.stdout):
    # timing statistics
    nb_of_pb = 0                # number of PB the path goes through
    net_time, pb_time = 0, 0    # timings
    prev = table[0]['id']
    for point in table[1:]:
        if point['id'] == prev:
            pb_time += point['incr']
        else:
            net_time += point['incr']
            nb_of_pb += 1
        prev = point['id']
    path = {
        'start'         : f"{table[0]['type']}[{table[0]['id']}]",
        'end'           : f"{table[-1]['type']}[{table[-1]['id']}]",
        'inter_pb'      : nb_of_pb - 1,
        'arrival_time'  : table[-1]['sum'],
        'path_time'     : table[-1]['sum'] - table[0]['sum'],
        'net_time'      : net_time,
        'inter_pb_time' : pb_time,
    }
    dist = manhattan_analysis(table)
    print("Path instance-to-instance   : {start} -> {end} (inter-PB: {inter_pb})".format(**path), file=stream)
    print("Data arrival time           : {arrival_time:.2f}".format(**path), file=stream)
    print("Path time (no clk-to-output): {path_time:.2f} (net: {net_time:.2f}, inter-PB: {inter_pb_time:.2f})".format(**path), file=stream)
    print("Manhattan distance          : {manhattan:4} (width: {m_width}, height: {m_height})".format(**dist), file=stream)
    print("Point-to-point path distance: {distance:4} (width: {d_width}, height: {d_height})".format(**dist), file=stream)
    print("Distance ratio              : {m_ratio:.2f}".format(**dist), file=stream)

## Print a given path using a table format
def print_path(path_id, ftiming, fnet, fplace, stream=sys.stdout):
    # path description
    print(f"# Path {ftiming[path_id].id}", file=stream)
    print(f"Startpoint: {ftiming[path_id][0]['point']}", file=stream)
    print(f"Endpoint  : {ftiming[path_id][-1]['point']}", file=stream)
    print(f"Path Type : {ftiming[path_id].type}\n", file=stream)
    # create the header structure
    headers = [
        ('point', "Point"),     # point name
        ('incr' , "Incr"),      # inter-point path time
        ('sum'  , "Path"),      # cumulated path time
        ('type' , "PB Type"),   # physical block type
        ('pin'  , "Pin"),       # pin direction (in/out)
        ('id'   , "Block"),     # block identifier
        ('coord', "Coords"),    # block coordinates
    ]
    table = []
    # create the table content
    for point in ftiming[path_id]:
        # point name
        pname = point['point']
        # block object
        block = fnet.find_block(pname)
        direc = block.direction[:-3]
        # block coordinates (x, y, subblk)
        x,y,sub = fplace.get_coordinates(block.id)
        # table row
        table.append({
            'point' : pname,
            'incr'  : point['incr'],
            'sum'   : point['sum'],
            'type'  : block.type,
            'pin'   : direc,
            'id'    : block.id,
            'coord' : f"({x:2},{y:2})",
            'x'     : x,
            'y'     : y,
        })
    print_table(table, headers, stream=stream)
    print_statistics(table, stream=stream)
    # separte path in the output file
    if stream is not sys.stdout:
        print(file=stream)

def main():
    # save user arguments
    args = parse_args()

    # setup/hold report timing file
    setuphold = "hold" if args.hold else "setup"
    # glob search
    search_root = os.path.join(args.search_path, "**")
    tim = find_filename(search_root, f"report_timing.{setuphold}.rpt")
    net = find_filename(search_root, "*.net")
    plc = find_filename(search_root, "*.place")

    # parsers
    tim = VprReportTimingParser(tim)
    net = VprNetParser(net)
    plc = VprPlaceParser(plc)

    # save all paths in a report file
    if args.output:
        # create the output directory if it's not existing
        dirname = os.path.abspath(os.path.dirname(args.output))
        if not os.path.isdir(dirname):
            os.makedirs(dirname)
        # create the file
        print(f"[+] Analyzing all paths, in progress...")
        with open(args.output, 'w') as fp:
            for idx, path in enumerate(tim):
                print_path(idx, tim, net, plc, stream=fp)
        print(f"[+] Output report generated: '{args.output}'")
    # single path printing (stdout)
    else:
        print_path(args.path_id, tim, net, plc)


if __name__ == "__main__":
    main()

