#!/usr/bin/env python3

import os, re, time
import numpy as np
from collections import OrderedDict

class BlifModel(object):
    """
    Define the model object to store all properties of each design and get
    additional information from the Verilog (BLIF) netlist.
    """
    def __init__(self, name, **kwargs):
        self.name       = name
        self.inputs     = kwargs.get('inputs', [])
        self.outputs    = kwargs.get('outputs', [])
        self.names      = OrderedDict()
        self.latches    = OrderedDict()
        self.subckts    = list()
        self.conns      = OrderedDict()

    def _split_point(self, point_name):
        """Separate the point name from its pin signal."""
        point = point_name.split('.')
        return '.'.join(point[:-1]), point[-1]

    def _get_subckt_pin(self, subckt, pin_name):
        """Return the subckt pin in the 'params' dictionary."""
        for signal, pins in subckt['params'].items():
            for pin in pins:
                if pin == pin_name:
                    return signal
        return None

    def get_names_pin(self, point_name):
        """Return the signal name for a point of a .names block."""
        output, pin_name = self._split_point(point_name)
        if output in self.names:
            pins = self.names[output]['pins']
            if pin_name in pins:
                return pins[pin_name]
        return None

    def get_latch_pin(self, point_name):
        """Return the signal name for a point of a .latch block."""
        output, pin_name = self._split_point(point_name)
        if output in self.latches:
            if pin_name in self.latches[output]:
                return self.latches[output][pin_name]
        return None

    def get_subckt_pin(self, point_name):
        """Return the signal name for a point of a .subckt block."""
        output, pin_name = self._split_point(point_name)
        for subckt in self.subckts:
            if output in subckt['params']:
                return self._get_subckt_pin(subckt, pin_name)
        return None

    def get_pin(self, point_name, point_type=None):
        """
        Return the right pin name for a given point in the path.

        - output_name: name of the unique output signal
        - pin_name: name of the pin (in/out) of the block
            - `names`: {'in[#]', 'out[#]'}
            - `latch`: {'D[0]', 'Q[0]'}
            - `subckt`: [data_out[#], data_in[#], ...]
        """
        if point_type:
            func = getattr(self, f"get_{point_type}_pin")
            return func(point_name)
        for point_type in ['names', 'latch', 'subckt']:
            func = getattr(self, f"get_{point_type}_pin")
            pin_name = func(point_name)
            if pin_name:
                return pin_name
        return None

    def get_instance(self, point_name):
        """Return the instance hierarchy naming of a subckt."""
        for subckt in self.subckts:
            if not 'inst' in subckt:
                continue
            output, pin_name = self._split_point(point_name)
            if output in subckt['params']:
                if self._get_subckt_pin(subckt, pin_name):
                    return subckt['inst']
        return None


class BlifParser(object):
    """
    Parse a BLIF or EBLIF file (generated by Yosys) to create a list of model
    objects (class BlifModel) which describe in the full design.

    Not supported BLIF primitives:
    - .exdc, .mlatch, .latch_order
    - Clock constraints: .cycle, .clock, .clock_event, .area, .delay, ...
    - FSM: .start_kiss, .end_kiss, .i, .o, .p, .s, .r

    Documentations:
    - BLFI format: https://www.cs.uic.edu/~jlillis/courses/cs594/spring05/blif.pdf
    """

    # Regex to extract BLIF netlist
    _rComment       = r'\s*#(?P<message>.+)'
    _rModel         = r'\.model (?P<name>[^\s#]+)'
    _rInputs        = r'\.inputs (?P<inputs>[^#]+)'
    _rOutputs       = r'\.outputs (?P<outputs>[^#]+)'
    _rLut           = r'\.names (?P<inputs>.+) (?P<output>[^\s#]+)'
    _rLutEq         = r'(?P<inputs>\d+) (?P<output>\d+)'
    _rLatch         = r'\.latch (?P<input>[^\s]+) (?P<output>[^\s]+)\s?((?P<type>[^\s]+) (?P<clk>[^\s]+))?\s?(?P<init>\d+)'
    _rSubckt        = r'\.subckt (?P<name>[^\s]+) (?P<params>[^#]+)'
    _rEnd           = r'\.end' # end of each model

    # Regex to extract EBLIF netlist
    _rCname         = r'\.cname (?P<name>[^\s]+)'
    _rAttr          = r'\.attr (?P<name>[^\s]+) (?P<value>[^\s#]+)'
    _rConn          = r'\.conn (?P<input>[^\s]+) (?P<output>[^\s#]+)'
    _rGate          = r'\.gate (?P<name>[^\s]+) (?P<params>[^#]+)'
    _rParam         = r'\.param (?P<name>[^\s]+) (?P<value>[^\s#]+)'

    # Compiled regexes (for faster parsing)
    _rcComment      = re.compile(_rComment)
    _rcModel        = re.compile(_rModel)
    _rcInputs       = re.compile(_rInputs)
    _rcOutputs      = re.compile(_rOutputs)
    _rcLut          = re.compile(_rLut)
    _rcLutEq        = re.compile(_rLutEq)
    _rcLatch        = re.compile(_rLatch)
    _rcSubckt       = re.compile(_rSubckt)
    _rcEnd          = re.compile(_rEnd)
    _rcCname        = re.compile(_rCname)
    _rcAttr         = re.compile(_rAttr)
    _rcConn         = re.compile(_rConn)

    def __init__(self, filename):
        self.filename   = filename
        self.models     = list()    # list of each model in the file
        self.parse()

    def __str__(self):
        """For debbuging purpose: print(object)."""
        table = []
        for m in self.models:
            table.append(f"model name: {m.name}")
            table.append(f"inputs: {' '.join(m.inputs)}")
            table.append(f"outputs: {' '.join(m.inputs)}")
            for name, lut in m.names.items():
                table.append(f".names {name}")
            for name, latch in m.latches.items():
                src  = latch['src'] if 'src' in latch else None
                table.append(f".latch {name} (src: {src})")
            for subckt in m.subckts:
                name = subckt['name']
                src  = subckt['src'] if 'src' in subckt else None
                inst = subckt['inst'] if 'inst' in subckt else None
                table.append(f".subckt {name} (inst: {inst}, src: {src})")
            for po, pi in m.conns.items():
                table.append(f".conn {po} = {pi}")
        return '\n'.join(table)

    def __len__(self):
        """Return the total number of paths."""
        return len(self.models)

    def __getitem__(self, idx):
        """Use this class as a list, in order to iterate each model."""
        if not self.models:
            return None
        return self.models[idx]

    def parse(self):
        """Parse the report file using the class regex."""
        # Parse the file
        with open(self.filename, 'r') as fp:
            model = None
            block = None
            # read the file line by line
            for line in fp.readlines():
                line = line.rstrip()
                # Just a comment or an empty line
                if len(line) == 0 or self._rcComment.match(line):
                    continue
                # Model object
                m = self._rcModel.match(line)
                if m:
                    model = BlifModel(m.groupdict()['name'])
                if self._rcEnd.match(line):
                    self.models.append(model)
                    model = None
                if model is None:
                    continue
                # Model inputs/outputs
                for attr, regex in zip(['inputs','outputs'],
                                       [self._rcInputs,self._rcOutputs]):
                    m = regex.match(line)
                    if m:
                        io_list = m.groupdict()[attr].strip().split()
                        setattr(model, attr, io_list)
                # LUT block (.names)
                m = self._rcLut.match(line)
                if m:
                    block, pins, m = {}, {}, m.groupdict()
                    for idx, pin in enumerate(m['inputs'].strip().split()):
                        pins[f'in[{idx}]'] = pin
                    pins['out[0]'] = m['output']
                    block['pins'] = pins
                    model.names[m['output']] = block
                # Latch/Flip-Flop block (.latch)
                m = self._rcLatch.match(line)
                if m:
                    block, m = dict(m.groupdict()), m.groupdict()
                    block['D[0]'] = block.pop('input')
                    block['Q[0]'] = block.pop('output')
                    model.latches[m['output']] = block
                # Subckt block (DSP, BRAM) (.subckt)
                m = self._rcSubckt.match(line)
                if m:
                    block, params, m = {}, {}, m.groupdict()
                    for p in m['params'].strip().split():
                        p = p.split('=')
                        # NOTE: VPR don't like single pin name, we need to
                        # change each single pin as a bus-type, such as:
                        # ren -> ren[0]
                        if not "[" in p[0]:
                            p[0] += "[0]"
                        if p[1] in params:
                            params[p[1]].append(p[0])
                        else:
                            params[p[1]] = [p[0]]
                    block['name'] = m['name']
                    block['params'] = params
                    model.subckts.append(block)
                # Conn block (direct wire connection)
                m = self._rcConn.match(line)
                if m:
                    m = m.groupdict()
                    model.conns[m['output']] = m['input']
                # Attributes
                m = self._rcAttr.match(line)
                if m and block is not None:
                    m = m.groupdict()
                    # list of source files
                    if m['name'] == "src":
                        m['value'] = m['value'].strip()[1:-1].split('|')
                    block[m['name']] = m['value']
                # Cname (Verilog instantiation)
                m = self._rcCname.match(line)
                if m and block is not None:
                    m = m.groupdict()
                    block['inst'] = m['name']

    def get_pin(self, point_name, point_type=None):
        """Return the pin name for a given point across all models."""
        for m in self.models:
            pin = m.get_pin(point_name, point_type)
            if pin is not None:
                return pin
        return None

    def get_instance(self, point_name):
        """Return the instance name of a given point across all models."""
        for m in self.models:
            inst = m.get_instance(point_name)
            if inst is not None:
                return inst
        return None

## Quick and dirty unit test
if __name__ == "__main__":
    import argparse, sys
    from pprint import pprint

    # Parse all arguments
    ap = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=argparse.RawTextHelpFormatter)
    ap.add_argument('blif_filename', type=str,
                    help="BLIF/EBLIF file to parse")
    ap.add_argument('--point', type=str,
                    help="print the signal name of a given point")
    ap.add_argument('-d', '--debug', action='store_true',
                    help="print the full content of the path list")
    args = ap.parse_args()

    obj = BlifParser(args.blif_filename)
    if not len(obj):
        print(f"[ERROR] no model found in the file: '{args.blif_filename}'")
        sys.exit(0)
    if args.debug:
        print(obj)
        sys.exit(0)
    if args.point:
        print(f"Looking for '{args.point}'")
        for model in obj:
            pin_name  = model.get_pin(args.point)
            inst_name = model.get_instance(args.point)
            print(f"{pin_name} (inst: {inst_name})")
        sys.exit(0)
    # default behavior
    for model in obj:
        if len(model.subckts):
            pprint(model.subckts[0])
        if len(model.names):
            pprint(list(model.names.items())[0])
        if len(model.latches):
            pprint(list(model.latches.items())[0])
