#!/usr/bin/env python3

"""
This Python library parses a ``.place`` file, generated by the VPR placer.
In this library, the ``VprPlaceParser`` object provide a method to retrieve
all physical block position on the FPGA grid.

>>> rpt = VprPlaceParser("<place-filename>")
>>> rpt.get_coordinates("a[0]")  # block coordinates containing the point 'a[0]'
>>> rpt.get_coordinates(10)      # block coordinates of the block ID #10
"""

import os, re

class VprPlaceParser(object):
    """Parse a ``.place`` file (generated by VPR) to extract block placement.
    This object save private look-up-table where block ID and point name are
    used as keys to get the block coordinates on the FPGA grid.

    Attributes:
        filename     (str)  : VPR ``.place`` file name to parse.
        headers      (list) : Column headers of the place file.
        netlist_file (str)  : Original netlist file name (optional).
        array_size   (tuple): Size of the FPGA device layout.

    Args:
        filename     (str)  : VPR ``.place`` file name to parse.
    """

    # Define the placement file format
    _rcNetlistFile  = re.compile(r'Netlist_File:\s+([^\s]+)')
    _rcNetlistId    = re.compile(r'Netlist_ID:\s+([^\s]+)')
    _rcArchFile     = re.compile(r'Architecture_File:\s+([^\s]+)')
    _rcArraySize    = re.compile(r'Array size: (\d+) x (\d+) logic blocks')
    _rcHeaderFormat = re.compile(r'#(block name)\s+(x)\s+(y)\s+(subblk)\s+(block number)')
    _rcComment      = re.compile(r'#.*')

    def __init__(self, filename):
        self.filename     = filename
        self.headers      = []
        self.netlist_file = ""
        self.array_size   = (None, None)
        self._block_ids   = {} # save all block by block id
        self._block_names = {} # save all block by block names
        self._parse()

    def _parse(self):
        """Parse the place file using the class regex."""
        with open(self.filename, 'r') as fp:
            for line in fp.readlines():
                line = line.rstrip()
                # File information
                m = self._rcNetlistFile.match(line)
                if m:
                    self.netlist_file = m.group(1)
                    continue
                m = self._rcArraySize.match(line)
                if m:
                    self.array_size = (int(m.group(1)), int(m.group(2)))
                    continue
                # Header format
                m = self._rcHeaderFormat.match(line)
                if m:
                    for header in m.groups():
                        self.headers.append(header.lower().replace(' ','_'))
                    continue
                # Ignore comment and empty lines
                if self._rcComment.match(line) or len(line) == 0:
                    continue
                # The following line must contain the position of all blocks
                line = line.split()
                if len(line) < len(self.headers):
                    continue
                block = {}
                for header, value in zip(self.headers, line):
                    block[header] = value
                # apply some patch to manipulate integer
                for header in ['x', 'y', 'subblk']:
                    if header in block:
                        block[header] = int(block[header])
                if 'block_number' in block:
                    block['block_number'] = int(block['block_number'].lstrip('#'))
                # update the block id and block name dictionaries
                coords = (block['x'], block['y'], block['subblk'])
                self._block_ids[block['block_number']] = coords
                self._block_names[block['block_name']] = coords

    def get_coordinates(self, block_id_or_name):
        """Get the block coordinates in th FPGA grid.

        Args:
            block_id_or_name (int, str): block identifier (integer) or point
                name (string) of the block position to be found.

        Returns:
            :obj:`tuple` (`x`, `y`, `sub`): block coordinates, :obj:`None`
            otherwise.
        """
        # for the block id search
        if isinstance(block_id_or_name, int):
            if block_id_or_name in self._block_ids:
                return self._block_ids[block_id_or_name]
        # for the block name search
        if isinstance(block_id_or_name, str):
            if block_id_or_name in self._block_names:
                return self._block_names[block_id_or_name]
        return None


if __name__ == "__main__":
    import argparse
    from pprint import pprint

    # Parse all arguments
    ap = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=argparse.RawTextHelpFormatter)
    ap.add_argument('place_filename', type=str,
                    help="VPR place file to parse")
    ap.add_argument('-d', '--debug', action='store_true',
                    help="print the full content of the path list")
    args = ap.parse_args()

    place = VprPlaceParser(args.place_filename)
    place.parse()
    print(place.array_size)
    print(place.get_coordinates(0))
    print(place.get_coordinates(1))
    print(place.get_coordinates("clk"))
    print(place.get_coordinates("iomem_rdata[0]"))
