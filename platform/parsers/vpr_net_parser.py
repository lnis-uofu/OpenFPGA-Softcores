#!/usr/bin/env python3

"""
This Python library parses a ``.net`` file, generated by the VPR packer.
In this library, the ``VprNetParser`` object provides methods to retrieve
`Physical Block` (PB) information. Since the XML structure could be consequent,
all PB are stored in a `Look-Up-Table` (LUT) with its associated `point` to
save execution time.

>>> rpt = VprNetParser("<net-filename>")
>>> rpt.get_block("a.in[0]") # return the Element object having the point 'a'
>>> rpt.get_pin("a.in[0]")   # return the pin name of 'in[0]' mapped on the PB
"""

import os, re
try:
    # Try for the fast c-based version first
    import xml.etree.cElementTree as ET
except ImportError:
    # Fall back on python implementation
    import xml.etree.ElementTree as ET


def pdebug(text, print_mesg=True, prefix="[DEBUG] ", retval=None):
    """Print a debugging message with the right format and return."""
    if print_mesg:
        print(f"{prefix}{text}")
    return retval


class VprNetParser(object):
    """
    Parse the XML structure describing the mapping of the benchmark design on
    the FPGA architecture target. Since this object is use collaboratively
    with the VPR timing report files, `points` are used to retrieve the block
    properties, such as `id`, `hierarchy` or `pin_name`.

    - `startpoints` are outputs, listed in the ``.place`` report,
    - `endpoints` are inputs, listed in the ``.route`` report.

    Attributes:
        filename (str) : XML file name to parse.
        debug    (bool): Enable the debugging mode.
        root     (`Element`): object pointing on the XML root instance.
        pbs      (list): List of `Element` refering to all Physical Blocks.
        lut      (dict): Look-up-table associating of every `point name` to
            its `Element` object for fast-searches.

    Args:
        filename (str): XML file name to parse.
        debug    (bool, optional): Enable the debugging mode
            (default: :obj:`None`).
    """

    def __init__(self, filename, debug=False):
        self.filename   = filename
        self.debug      = debug
        self.root       = ET.parse(filename).getroot()
        self.pbs        = self.root.findall('block')
        self.lut        = {}
        self._add_properties()
        self._create_lut()

    def _add_properties(self):
        """Insert the block ID, and the parent hierarchy in the XML object."""
        # for each physical block in the FPGA
        for block in self.pbs:
            pb_id     = int(block.attrib['instance'][:-1].split('[')[-1])
            subb_name = None
            # for each sub-block inside the physical block
            for subb in block.iter('block'):
                # avoid open states
                if subb.attrib['name'] == "open":
                    continue
                # add the physical block identifier
                subb.set('pb_id', pb_id)
                # add the parent hierarchy
                if subb_name == subb.attrib['name']:
                    hierarchy.append(subb.attrib['instance'])
                else:
                    subb_name = None
                if subb_name is None:
                    subb_name = subb.attrib['name']
                    hierarchy = [block.attrib['instance']]
                subb.set('hierarchy', '->'.join(hierarchy))

    def _create_lut(self):
        """Create the LUT associating each point name to its block."""
        # for each sub-block inside the physical block
        for block in self.pbs:
            # for each sub-block inside the physical block
            for subb in block.iter('block'):
                self.lut[subb.attrib['name']] = subb

    def get_block(self, point_name):
        """Get the block object containing the given `point_name`.

        Args:
            point_name (str): Point name of the block to be found.

        Returns:
            ``Element``: block object, :obj:`None` otherwise.
        """
        block_name = '.'.join(point_name.split('.')[:-1])
        return self.lut[block_name]

    def get_pin(self, point_name, block=None):
        """Get the pin name of block containing the given `point_name`.

        Args:
            point_name (str): Point name of the block to be found.
            block (obj): ``Element`` object containing the point and pin.
                Giving the block as parameter will save execution time.

        Returns:
            :obj:`tuple` (`name`, `direction`): pin description, :obj:`None` otherwise.
        """
        if block is None:
            block = self.get_block(point_name)
        if block is None:
            return None
        # get the port name and the pin ID from the point name
        port_name, pin_id = point_name.split('.')[-1][:-1].split('[')
        # get the pin name (when input)
        if block.find(f"./inputs/port/[@name='{port_name}']") is not None:
            return ('.'.join(point_name.split('.')[:-1]), "in")
        # when output:
        port = block.find(f"./outputs/port/[@name='{port_name}']")
        if port is not None:
            pins = port.text.split()
            if len(pins) > int(pin_id):
                return (pins[int(pin_id)], "out")
        return None

    def print_point(self, point_name):
        """Quick & Dirty debugging method to print point properties.

        Args:
            point_name (str): Point name of the block to be printed.
        """
        block = self.get_block(point_name)
        if block is None:
            pdebug("Missing block info", self.debug)
            return
        pin, direction = self.get_pin(point_name, block)
        hierarchy = block.get('hierarchy')
        pb_id     = block.get('pb_id')
        # print the result
        print(f"{point_name:70} | {direction:6} | {pb_id:3} | {hierarchy:45} | {pin}")


if __name__ == "__main__":
    import argparse

    # Parse all arguments
    ap = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=argparse.RawTextHelpFormatter)
    ap.add_argument('net_filename', type=str,
                    help="VPR net (xml) file to parse")
    ap.add_argument('-d', '--debug', action='store_true',
                    help="print debugging information")
    args = ap.parse_args()

    vnp = VprNetParser(args.net_filename, debug=args.debug)
    # list of start and end points
    # FIXME: basic test with picosoc (BRAM+DSP) to remove afterall
    vnp.print_point("$auto$memory_bram.cc:1005:replace_memory$7212.B[24].data_out[7]")
    vnp.print_point("$abc$136328$aiger136327$2736.in[2]")
    vnp.print_point("$abc$136328$aiger136327$2736.out[0]")
    vnp.print_point("$abc$136328$aiger136327$2739.in[0]")
    vnp.print_point("$abc$136328$aiger136327$2739.out[0]")
    vnp.print_point("$abc$136328$aiger136327$2757.in[0]")
    vnp.print_point("$abc$136328$aiger136327$2757.out[0]")
    vnp.print_point("$abc$136328$aiger136327$2760.in[2]")
    vnp.print_point("$abc$136328$aiger136327$2760.out[0]")
    vnp.print_point("cpu.mem_rdata_latched[0].in[4]")
    vnp.print_point("cpu.mem_rdata_latched[0].out[0]")
    vnp.print_point("$abc$136328$aiger136327$3465.in[0]")
    vnp.print_point("$abc$136328$aiger136327$3465.out[0]")
    vnp.print_point("$abc$136328$aiger136327$4013.in[0]")
    vnp.print_point("$abc$136328$aiger136327$4013.out[0]")
    vnp.print_point("$abc$136328$flatten\cpu.$0\decoded_rs1[4:0][3].in[0]")
    vnp.print_point("$abc$136328$flatten\cpu.$0\decoded_rs1[4:0][3].out[0]")
    vnp.print_point("$abc$136328$auto$mem.cc:1149:emulate_transparency$6488[0].raddr[6]")
    vnp.print_point("$techmap5610$flatten\cpu.\genblk1.pcpi_mul.$mul$./benchmark/picorv32.v:2366$857.Y[0].A[1]")
    vnp.print_point("$techmap5610$flatten\cpu.\genblk1.pcpi_mul.$mul$./benchmark/picorv32.v:2366$857.Y[0].Y[60]")

