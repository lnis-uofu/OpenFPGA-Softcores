#!/usr/bin/env python3

import os, re

class VprPlaceParser(object):
    """
    Parse a place file (generated by VPR) to obtain the final coordinates on
    the FPGA architecture grid.
    """

    # Define the placement file format
    _rcNetlistFile  = re.compile(r'Netlist_File:\s+([^\s]+)')
    _rcNetlistId    = re.compile(r'Netlist_ID:\s+([^\s]+)')
    _rcArchFile     = re.compile(r'Architecture_File:\s+([^\s]+)')
    _rcArraySize    = re.compile(r'Array size: (\d+) x (\d+) logic blocks')
    _rcHeaderFormat = re.compile(r'#(block name)\s+(x)\s+(y)\s+(subblk)\s+(block number)')
    _rcComment      = re.compile(r'#.*')

    def __init__(self, filename):
        self.filename     = filename
        self.headers      = []
        self.netlist_file = ""
        self.array_size   = (None, None)
        self._block_ids   = {} # save all block by block id
        self._block_names = {} # save all block by block names
        self.parse()

    def parse(self):
        """Parse the place file using the class regex."""
        with open(self.filename, 'r') as fp:
            for line in fp.readlines():
                line = line.rstrip()
                # File information
                m = self._rcNetlistFile.match(line)
                if m:
                    self.netlist_file = m.group(1)
                    continue
                m = self._rcArraySize.match(line)
                if m:
                    self.array_size = (int(m.group(1)), int(m.group(2)))
                    continue
                # Header format
                m = self._rcHeaderFormat.match(line)
                if m:
                    for header in m.groups():
                        self.headers.append(header.lower().replace(' ','_'))
                    continue
                # Ignore comment and empty lines
                if self._rcComment.match(line) or len(line) == 0:
                    continue
                # The following line must contain the position of all blocks
                line = line.split()
                if len(line) < len(self.headers):
                    continue
                block = {}
                for header, value in zip(self.headers, line):
                    block[header] = value
                # apply some patch to manipulate integer
                for header in ['x', 'y', 'subblk']:
                    if header in block:
                        block[header] = int(block[header])
                if 'block_number' in block:
                    block['block_number'] = int(block['block_number'].lstrip('#'))
                # update the block id and block name dictionaries
                coords = (block['x'], block['y'], block['subblk'])
                self._block_ids[block['block_number']] = coords
                self._block_names[block['block_name']] = coords

    def get_coordinates(self, block_id_or_name):
        """Return a tuple of the block position in the grid."""
        # for the block id search
        if isinstance(block_id_or_name, int):
            if block_id_or_name in self._block_ids:
                return self._block_ids[block_id_or_name]
        # for the block name search
        if isinstance(block_id_or_name, str):
            if block_id_or_name in self._block_names:
                return self._block_names[block_id_or_name]
        return None


if __name__ == "__main__":
    import argparse
    from pprint import pprint

    # Parse all arguments
    ap = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=argparse.RawTextHelpFormatter)
    ap.add_argument('place_filename', type=str,
                    help="VPR place file to parse")
    ap.add_argument('-d', '--debug', action='store_true',
                    help="print the full content of the path list")
    args = ap.parse_args()

    place = VprPlaceParser(args.place_filename)
    place.parse()
    print(place.array_size)
    print(place.get_coordinates(0))
    print(place.get_coordinates(1))
    print(place.get_coordinates("clk"))
    print(place.get_coordinates("iomem_rdata[0]"))
